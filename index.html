<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JessieMath - å¢æ—åæ“Šæˆ°</title>
    <style>
        /* --- UI è¨­è¨ˆï¼šç§‘æŠ€èˆ‡åŸå§‹çš„çµåˆ --- */
        :root {
            --neon-blue: #00f3ff;
            --neon-green: #39ff14;
            --neon-gold: #ffd700;
            --neon-red: #ff3333;
            --hud-bg: rgba(0, 20, 10, 0.85);
        }

        body { margin: 0; overflow: hidden; background: #050a05; font-family: 'Segoe UI', sans-serif; }
        
        #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; display: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: none; }

        /* --- æ–°å¢ï¼šå…¨å±€é­”å¹»ç‰¹æ•ˆå±¤ (æœ€åº•å±¤) --- */
        #global-magic-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 0; overflow: hidden;
        }

        /* ç²¾éˆé­”æ³•å¾®å¡µ */
        .magic-spark {
            position: absolute;
            width: 4px; height: 4px;
            background: radial-gradient(circle, #ffd700 20%, transparent 70%); /* é‡‘è‰²æ ¸å¿ƒ */
            box-shadow: 0 0 10px #ffd700, 0 0 20px #39ff14; /* é‡‘ç¶ è‰²å…‰æšˆ */
            border-radius: 50%;
            opacity: 0;
            animation: magicDrift linear infinite;
        }

        @keyframes magicDrift {
            0% { transform: translate(0, 110vh) rotate(0deg) scale(0.5); opacity: 0; }
            20% { opacity: 0.8; }
            80% { opacity: 0.6; }
            100% { transform: translate(20vw, -20vh) rotate(180deg) scale(1.2); opacity: 0; }
        }

        /* --- ç™»å…¥èˆ‡æ—¥èªŒé é¢ --- */
        #intro-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            /* å¾®èª¿èƒŒæ™¯ï¼šåŠ å…¥ä¸€é»æ·±ç¶ è‰²èª¿ï¼Œå¢åŠ é­”å¹»æ£®æ—æ„Ÿ */
            background: radial-gradient(circle at center, #0b1a2b 0%, #051405 60%, #000 100%);
            z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff;
            overflow: hidden;
        }

        /* æ—¢æœ‰çš„è—è‰²ç§‘æŠ€å…‰é» (å±¤ç´š1) */
        #particles-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1;
        }

        .particle {
            position: absolute;
            background: var(--neon-blue);
            border-radius: 50%;
            opacity: 0;
            box-shadow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue);
            animation: floatUp linear infinite;
        }

        /* èƒŒæ™¯æ¼‚æµ®ç…§ç‰‡å®¹å™¨ (å±¤ç´š2) */
        #bg-gallery {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 2; 
        }

        /* ä¿®æ”¹é‡é»ï¼šè®“èƒŒæ™¯åœ–ç‰‡æ›´æ·±ã€æ›´æ˜é¡¯ */
        .bg-floating-img {
            position: absolute;
            opacity: 0;
            border-radius: 8px;
            /* å¢åŠ ä¸€é»é‡‘è‰²é‚Šæ¡†å…‰æšˆï¼Œå‘¼æ‡‰é­”å¹»ä¸»é¡Œ */
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.1), 0 0 5px rgba(255, 215, 0, 0.2);
            object-fit: cover;
            animation: floatImg linear infinite;
            /* é™ä½äº®åº¦ï¼Œæé«˜å°æ¯”ï¼Œè®“å®ƒçœ‹èµ·ä¾†åƒæ·±è‰²å‰ªå½± */
            filter: grayscale(50%) brightness(0.4) contrast(1.3);
        }

        @keyframes floatUp {
            0% { transform: translateY(100vh) scale(0); opacity: 0; }
            20% { opacity: 0.8; }
            80% { opacity: 0.5; }
            100% { transform: translateY(-10vh) scale(1.5); opacity: 0; }
        }

        /* ä¿®æ”¹é‡é»ï¼šæé«˜å‹•ç•«éç¨‹ä¸­çš„ä¸é€æ˜åº¦ */
        @keyframes floatImg {
            0% { transform: translateY(110vh) rotate(0deg); opacity: 0; }
            10% { opacity: 0.5; } /* æé«˜åˆ° 0.5 */
            90% { opacity: 0.5; } /* ä¿æŒåœ¨ 0.5 */
            100% { transform: translateY(-20vh) rotate(360deg); opacity: 0; }
        }

        .intro-container {
            display: flex; gap: 40px; align-items: center;
            /* èƒŒæ™¯ç¨å¾®å¸¶é»å¢¨ç¶ è‰²èª¿ */
            background: rgba(0, 25, 30, 0.85); 
            padding: 40px;
            border: 2px solid var(--neon-blue);
            /* å¢åŠ ä¸€é»é‡‘è‰²å…‰æšˆæ··åˆ */
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.3), 0 0 20px rgba(255, 215, 0, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            z-index: 10;
            position: relative;
        }

        .slide-frame {
            width: 300px; height: 350px;
            border: 4px solid var(--neon-green);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px var(--neon-green);
            position: relative;
            background: #000;
            display: flex; flex-direction: column;
        }

        .img-wrapper {
            width: 100%; height: 280px; overflow: hidden;
        }

        #slide-img {
            width: 100%; height: 100%;
            object-fit: cover;
            transition: opacity 0.5s ease-in-out;
        }
        
        .slide-label {
            width: 100%; height: 70px;
            background: rgba(0,20,0,0.9);
            color: var(--neon-blue); 
            text-align: center; 
            display: flex; justify-content: center; align-items: center;
            font-size: 1rem; font-weight: bold;
            padding: 5px; box-sizing: border-box;
            border-top: 2px solid var(--neon-green);
            line-height: 1.4;
        }

        .login-panel {
            display: flex; flex-direction: column; gap: 20px; width: 300px;
        }

        .login-title {
            color: var(--neon-blue); font-size: 2rem; margin: 0; 
            text-shadow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-green); /* æ¨™é¡Œå¢åŠ ä¸€é»ç¶ è‰²å…‰æšˆ */
            font-style: italic; text-align: center;
        }

        input[type="text"] {
            background: rgba(0,0,0,0.5); border: 2px solid #555; color: #fff;
            padding: 15px; font-size: 1.2rem; border-radius: 8px; text-align: center; outline: none;
            transition: 0.3s;
        }
        input[type="text"]:focus { border-color: var(--neon-blue); box-shadow: 0 0 10px var(--neon-blue); }

        .btn-start {
            background: linear-gradient(45deg, #006064, #00bcd4); border: none; color: white;
            padding: 15px; font-size: 1.2rem; font-weight: bold; border-radius: 8px; cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 188, 212, 0.4); transition: 0.3s;
        }
        .btn-start:hover { transform: scale(1.05); filter: brightness(1.2); }

        .btn-rank {
            background: transparent; border: 2px solid var(--neon-gold); color: var(--neon-gold);
            padding: 10px; font-size: 1rem; font-weight: bold; border-radius: 8px; cursor: pointer;
            transition: 0.3s; text-align: center;
        }
        .btn-rank:hover { background: rgba(255, 215, 0, 0.1); box-shadow: 0 0 10px var(--neon-gold); }

        /* æ’è¡Œæ¦œè¦–çª— */
        #leaderboard-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 400px; background: rgba(10, 15, 10, 0.95);
            border: 2px solid var(--neon-gold); border-radius: 15px;
            padding: 20px; display: none; z-index: 1000; color: #fff;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.2);
        }
        .lb-title { text-align: center; color: var(--neon-gold); margin-top: 0; }
        .lb-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
        .lb-table th { text-align: left; color: #aaa; border-bottom: 1px solid #333; padding: 5px; }
        .lb-table td { padding: 8px 5px; border-bottom: 1px solid #222; }
        .lb-close { display: block; width: 100%; padding: 10px; background: #333; color: #fff; border: none; cursor: pointer; }

        /* --- æ—¢æœ‰ç‰¹æ•ˆ --- */
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%);
            opacity: 0; transition: opacity 0.2s; pointer-events: none; z-index: 5;
        }

        #warp-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, transparent 0%, #000 150%);
            z-index: 100; pointer-events: none; opacity: 0;
            transition: opacity 0.1s;
            display: flex; justify-content: center; align-items: center;
        }
        
        .ripple {
            position: absolute;
            border-radius: 50%;
            border: 5px solid var(--neon-blue);
            opacity: 0;
            box-shadow: 0 0 50px var(--neon-blue);
        }

        .warping #warp-overlay {
            opacity: 1;
            background: radial-gradient(circle at center, rgba(0, 243, 255, 0.2) 0%, #000 90%);
            backdrop-filter: blur(10px) hue-rotate(90deg);
            transition: all 1.5s ease-in;
        }
        
        .warping .ripple {
            animation: rippleAnim 1.5s ease-in forwards;
        }

        @keyframes rippleAnim {
            0% { width: 0; height: 0; opacity: 1; border-width: 20px; }
            100% { width: 200vw; height: 200vw; opacity: 0; border-width: 0px; }
        }

        header {
            position: absolute; top: 0; width: 100%; padding: 20px;
            display: flex; justify-content: space-between; align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            box-sizing: border-box;
        }
        .game-title h1 {
            color: var(--neon-blue); margin: 0; font-size: 1.8rem; font-style: italic;
            text-shadow: 0 0 10px var(--neon-blue);
        }
        .game-title span { color: #fff; font-size: 0.9rem; letter-spacing: 1px; }

        .mission-stats {
            background: var(--hud-bg); color: var(--neon-gold);
            padding: 10px 25px; border-radius: 30px; border: 2px solid var(--neon-gold);
            font-weight: bold; text-align: right;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            margin-right: 160px;
        }

        #minimap-container {
            position: absolute; top: 20px; right: 20px;
            width: 150px; height: 150px;
            border-radius: 50%;
            border: 4px solid var(--neon-green);
            background: rgba(0, 10, 0, 0.9);
            overflow: hidden;
            box-shadow: 0 0 20px var(--neon-green);
            z-index: 20;
        }
        #minimap-canvas { width: 100%; height: 100%; }

        .speedometer {
            position: absolute; bottom: 30px; left: 30px;
            width: 110px; height: 110px; border-radius: 50%;
            background: var(--hud-bg);
            border: 4px solid var(--neon-blue);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            box-shadow: 0 0 20px var(--neon-blue);
            backdrop-filter: blur(5px);
        }
        .speed-val { color: #fff; font-size: 2.5rem; font-weight: 800; }
        .speed-label { color: var(--neon-blue); font-size: 0.8rem; }

        #hint-box {
            position: absolute; bottom: 150px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); color: #fff;
            padding: 12px 30px; border-radius: 50px; border: 2px solid #fff;
            font-size: 1.2rem; font-weight: bold; display: none;
            animation: bounce 1s infinite;
            white-space: nowrap;
        }
        @keyframes bounce { 0%, 100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(-10px); } }

        #combat-hint {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            color: var(--neon-green); font-size: 0.9rem; font-weight: bold;
            text-shadow: 0 0 5px var(--neon-green);
            text-align: center;
            width: 100%;
        }

        #mission-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 450px; padding: 30px;
            background: rgba(10, 25, 35, 0.95);
            border: 2px solid var(--neon-green); border-radius: 15px;
            box-shadow: 0 0 50px rgba(57, 255, 20, 0.3);
            display: none; pointer-events: auto; text-align: center; color: #fff;
            z-index: 200;
        }
        .m-header { color: var(--neon-green); font-size: 1.6rem; margin-bottom: 10px; text-transform: uppercase; }
        .m-desc { color: #ccc; margin-bottom: 25px; line-height: 1.5; }
        .btn-grid { display: grid; gap: 15px; }
        .btn {
            display: block; padding: 12px; border-radius: 8px; text-decoration: none; font-weight: bold; color: white; transition: 0.3s;
        }
        .btn:hover { transform: scale(1.03); filter: brightness(1.2); }
        .btn-1 { background: #2e7d32; border: 1px solid #4caf50; }
        .btn-2 { background: #1565c0; border: 1px solid #42a5f5; }
        .btn-3 { background: #6a1b9a; border: 1px solid #ab47bc; }
        
        .close-btn {
            margin-top: 20px; background: transparent; border: 1px solid #666; color: #aaa;
            padding: 5px 20px; border-radius: 20px; cursor: pointer;
        }
        .close-btn:hover { border-color: #fff; color: #fff; }

        #reward-msg {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            font-size: 1.5rem; color: var(--neon-gold); font-weight: bold;
            text-shadow: 0 0 20px var(--neon-gold); opacity: 0; pointer-events: none;
            transition: opacity 0.5s; text-align: center;
        }
        
        #hq-warning {
            position: absolute; top: 30%; width: 100%; text-align: center;
            color: var(--neon-red); font-size: 2rem; font-weight: 900;
            text-shadow: 0 0 20px red; display: none;
            animation: blink 0.5s infinite alternate;
        }
        @keyframes blink { from {opacity: 1;} to {opacity: 0.3;} }
    </style>
</head>
<body>

    <div id="global-magic-overlay"></div>

    <div id="intro-layer">
        <div id="particles-container"></div>
        <div id="bg-gallery"></div>

        <div class="intro-container">
            <div class="slide-frame">
                <div class="img-wrapper">
                    <img id="slide-img" src="1.jpg" alt="Mission Preview">
                </div>
                <div class="slide-label" id="slide-label">G5-U1 ç”Ÿå‘½ä¹‹æ¨¹å¿ƒè·³ æŠ˜ç·šåœ–</div>
            </div>
            
            <div class="login-panel">
                <h1 class="login-title">JessieMath</h1>
                <input type="text" id="hero-name" placeholder="è«‹è¼¸å…¥å‹‡è€…åå­—" maxlength="12">
                <button class="btn-start" onclick="startGame()">â–¶ å•Ÿå‹•å¼•æ“</button>
                <button class="btn-rank" onclick="toggleLeaderboard()">ğŸ† å‹‡è€…æ’è¡Œæ¦œ</button>
            </div>
        </div>
    </div>

    <div id="leaderboard-modal">
        <h2 class="lb-title">TOP SURVIVORS</h2>
        <table class="lb-table" id="lb-table-body">
            <tr><th>æ’å</th><th>å‹‡è€…ä»£è™Ÿ</th><th>å®Œæˆåº¦</th></tr>
            <tr><td>1</td><td>Alpha</td><td>21/21</td></tr>
            <tr><td>2</td><td>Beta_Rider</td><td>18/21</td></tr>
            <tr><td>3</td><td>JungleKid</td><td>12/21</td></tr>
        </table>
        <button class="lb-close" onclick="toggleLeaderboard()">é—œé–‰</button>
    </div>

    <div id="ui-layer">
        <div id="damage-overlay"></div>
        
        <div id="warp-overlay">
            <div class="ripple"></div>
            <div class="ripple" style="animation-delay: 0.3s"></div>
            <div class="ripple" style="animation-delay: 0.6s"></div>
        </div>

        <header>
            <div class="game-title">
                <h1>JUNGLE MOTO</h1>
                <span>MATH SURVIVAL G5</span>
            </div>
            <div class="mission-stats">
                å‹‡è€…: <span id="display-name" style="color:var(--neon-blue)">æœªç™»å…¥</span> | 
                ä»»å‹™: <span id="progress">0</span> / 21<br>
                äººé¡å¨è„…åº¦: <span id="threat-level">æ¥µé«˜</span>
            </div>
        </header>

        <div id="minimap-container">
            <canvas id="minimap-canvas" width="150" height="150"></canvas>
        </div>

        <div class="speedometer">
            <span class="speed-val" id="speed-display">0</span>
            <span class="speed-label">KM/H</span>
        </div>

        <div id="hint-box">ç™¼ç¾ç›®æ¨™</div>
        <div id="combat-hint">æŒ‰ [ç©ºç™½éµ] ç™¼å°„æ¯’æ°£ | å°å¿ƒäººé¡æ”»æ“Šï¼</div>
        <div id="reward-msg">ç²å¾—ç‰©è³‡ï¼</div>
        <div id="hq-warning">âš  äººé¡ç¸½éƒ¨å·²æš´éœ² âš <br>å‰å¾€é›·é”é»ƒè‰²å€åŸŸæ‘§æ¯€å®ƒï¼</div>

        <div id="mission-modal">
            <h2 class="m-header" id="m-title">TITLE</h2>
            <p class="m-desc" id="m-desc">description...</p>
            <div class="btn-grid">
                <a href="#" target="_blank" class="btn btn-1" id="link-1" onclick="getLoot()">åŸºç¤ä»»å‹™ (ç‰©è³‡)</a>
                <a href="#" target="_blank" class="btn btn-2" id="link-2" onclick="getLoot()">é€²éšæŒ‘æˆ° (æ­¦å™¨)</a>
                <a href="#" target="_blank" class="btn btn-3" id="link-3" onclick="getLoot()">éŠæˆ²å¯¦æˆ° (åœ°ç›¤)</a>
            </div>
            <button class="close-btn" onclick="closeUI()">é—œé–‰è¦–çª—</button>
        </div>
    </div>

    <canvas id="game-canvas"></canvas>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        // --- 0. å…¨åŸŸæ§åˆ¶èˆ‡éŸ³æ•ˆ ---
        let gameStarted = false;
        let playerName = "";
        
        const audioEnter = new Audio('1.mp3'); 
        const audioEngine = new Audio('2.mp3');
        const audioShoot = new Audio('3.mp3'); 
        const audioWarp = new Audio('4.mp3');  

        audioEngine.loop = true;
        audioEngine.volume = 0.5;

        // --- 1. æ—¥èªŒè¼ªæ’­èˆ‡ç™»å…¥é‚è¼¯ ---
        
        // æ—¢æœ‰çš„è—è‰²å…‰é»ç‰¹æ•ˆ
        function createParticles() {
            const container = document.getElementById('particles-container');
            const particleCount = 60; 

            for (let i = 0; i < particleCount; i++) {
                const p = document.createElement('div');
                p.classList.add('particle');
                const size = Math.random() * 5 + 2; 
                p.style.width = `${size}px`; p.style.height = `${size}px`;
                p.style.left = `${Math.random() * 100}%`; p.style.top = `${Math.random() * 100}%`;
                const duration = Math.random() * 10 + 5; const delay = Math.random() * 5;
                p.style.animationDuration = `${duration}s`; p.style.animationDelay = `-${delay}s`;
                container.appendChild(p);
            }
        }
        createParticles();

        // æ–°å¢ï¼šå…¨å±€é­”å¹»å¾®å¡µç‰¹æ•ˆ
        function createMagicSparks() {
            const container = document.getElementById('global-magic-overlay');
            const sparkCount = 40; // é­”æ³•å¾®å¡µæ•¸é‡

            for (let i = 0; i < sparkCount; i++) {
                const s = document.createElement('div');
                s.classList.add('magic-spark');
                // éš¨æ©Ÿä½ç½®
                s.style.left = `${Math.random() * 100}%`;
                // éš¨æ©Ÿå‹•ç•«æ™‚é–“èˆ‡å»¶é²ï¼Œè£½é€ éŒ¯è½æ„Ÿ
                const duration = Math.random() * 15 + 10; // 10-25ç§’
                const delay = Math.random() * 20;
                s.style.animationDuration = `${duration}s`;
                s.style.animationDelay = `-${delay}s`;
                container.appendChild(s);
            }
        }
        createMagicSparks();

        // èƒŒæ™¯éš¨æ©Ÿæ¼‚æµ®ç…§ç‰‡ç”Ÿæˆå‡½æ•¸
        function createBgGallery() {
            const container = document.getElementById('bg-gallery');
            const totalUnits = 21; 
            
            for (let i = 1; i <= totalUnits; i++) {
                const img = document.createElement('img');
                img.src = `${i}.jpg`; 
                img.classList.add('bg-floating-img');
                
                const size = Math.random() * 70 + 80; 
                img.style.width = `${size}px`; img.style.height = `${size}px`; 
                img.style.left = `${Math.random() * 95}%`;
                
                const duration = Math.random() * 20 + 15; 
                const delay = Math.random() * 30;
                img.style.animationDuration = `${duration}s`;
                img.style.animationDelay = `-${delay}s`;
                
                container.appendChild(img);
            }
        }
        createBgGallery();

        // å–®å…ƒåˆ—è¡¨
        const units = [
            { id: 1, code: "G5-U1", name: "ç”Ÿå‘½ä¹‹æ¨¹å¿ƒè·³", topic: "æŠ˜ç·šåœ–", desc: "ç´€éŒ„èƒ½é‡èµ·ä¼" },
            { id: 2, code: "G5-U2", name: "éˆé­‚ç¨®å­åˆ†èš", topic: "å€æ•¸èˆ‡å› æ•¸", desc: "å°‹æ‰¾æ’åˆ—è¦å¾‹" },
            { id: 3, code: "G5-U3", name: "åŸå§‹éƒ¨è½åœ–é¨°", topic: "å¹³é¢åœ–å½¢", desc: "è¾¨è­˜å¹¾ä½•è‘‰ç‰‡" },
            { id: 4, code: "G5-U4", name: "è¢å…‰å‘¨æœŸé‡åˆ", topic: "å…¬å€èˆ‡å…¬å› ", desc: "è¨ˆç®—ç™¼å…‰æ™‚åˆ»" },
            { id: 5, code: "G5-U5", name: "æ´çªŸæ™¶é«”æ¡é›†", topic: "ç«‹é«”å½¢é«”", desc: "åˆ‡å‰²ç«‹é«”ç¤¦çŸ³" },
            { id: 6, code: "G5-U6", name: "è—¥è‰ç…‰é‡‘è¡“", topic: "å››å‰‡é‹ç®—", desc: "è—¥è‰æ··åˆé‹ç®—" },
            { id: 7, code: "G5-U7", name: "æºªæµæºé ­åˆ†é…", topic: "æ“´ç´„åˆ†åŠ æ¸›", desc: "èª¿æ•´æ°´é‡æ¯”ä¾‹" },
            { id: 8, code: "G5-U8", name: "æ‡¸æµ®å³¶æ¤è¢«ç‰†", topic: "é¢ç©", desc: "è¨ˆç®—ç¶ åŒ–é¢ç©" },
            { id: 9, code: "G5-U9", name: "èƒ½é‡çƒç¸®å°", topic: "ä¹˜å¹¾åˆ†ä¹‹ä¸€", desc: "èƒ½é‡æ¯”ä¾‹ç¸®å°" },
            { id: 10, code: "G5-U10", name: "å¥‡å¹»èŠ±æœµç¶»æ”¾", topic: "æ‰‡å½¢", desc: "èŠ±ç“£è§’åº¦è¨ˆç®—" },
            { id: 11, code: "G5-U11", name: "é å¤è¨ˆæ•¸çŸ³åˆ»", topic: "åé€²ä½çµæ§‹", desc: "ç ´è§£ä½å€¼çµæ§‹" },
            { id: 12, code: "G5-U12", name: "æ—äººçµç‰©åˆ†é…", topic: "åˆ†æ•¸è¨ˆç®—", desc: "è³‡æºç²¾ç´°åˆ‡åˆ†" },
            { id: 13, code: "G5-U13", name: "èƒ½é‡æ± å®¹ç©", topic: "é«”ç©", desc: "è¨ˆç®—è²¯å­˜é«”ç©" },
            { id: 14, code: "G5-U14", name: "ç²¾å¾®æ¯’ç´ åˆ†æ", topic: "å°æ•¸", desc: "æ¸¬é‡å¾®é‡æ¨£æœ¬" },
            { id: 15, code: "G5-U15", name: "å¢æ—ç¸½é«”ç©é‡", topic: "ç”Ÿæ´»å¤§å–®ä½", desc: "ä¼°è¨ˆæ£®æ—ç¸½é‡" },
            { id: 16, code: "G5-U16", name: "æ˜Ÿç³»è»Œé“è¨ˆç®—", topic: "æ™‚é–“ä¹˜é™¤", desc: "ç”Ÿé•·é€±æœŸé‹ç®—" },
            { id: 17, code: "G5-U17", name: "åŸå§‹çŸ³ç¼¸ç››æ°´", topic: "å®¹ç©", desc: "å®¹å™¨æ’æ°´æ³•" },
            { id: 18, code: "G5-U18", name: "æ£®æ—æ·¨åŒ–ç‡", topic: "æ¯”ç‡ç™¾åˆ†ç‡", desc: "è¨ˆç®—æ·¨åŒ–æ¯”ä¾‹" },
            { id: 19, code: "G5-U19", name: "ç™¼å…‰æœå¯¦åŒ…è£", topic: "è¡¨é¢ç©", desc: "è¡¨å±¤é¢ç©è¨ˆç®—" },
            { id: 20, code: "G5-U20", name: "ç¥ç¥•è´è¶ç¿…è†€", topic: "ç·šå°ç¨±åœ–å½¢", desc: "ä¿®å¾©å°ç¨±ç”Ÿç‰©" },
            { id: 21, code: "G5-U21", name: "æ¨£æœ¬ç²¾ç¢ºç¸½åˆ", topic: "å°æ•¸åŠ æ¸›", desc: "åˆä½µå¾®é‡æ¨£æœ¬" }
        ];

        let slideIdx = 0;
        const slideImg = document.getElementById('slide-img');
        const slideLabel = document.getElementById('slide-label');
        
        // åˆå§‹åŒ–ç¬¬ä¸€å¼µæ–‡å­—
        slideLabel.innerText = `${units[0].code} ${units[0].name} ${units[0].topic}`;

        // è‡ªå‹•è¼ªæ’­
        setInterval(() => {
            slideIdx = (slideIdx + 1) % units.length;
            slideImg.src = `${units[slideIdx].id}.jpg`; // å‡è¨­åœ–ç‰‡æª”åç‚º 1.jpg, 2.jpg...
            // æ›´æ–°æ–‡å­—æ ¼å¼ï¼šG5-U1 ç”Ÿå‘½ä¹‹æ¨¹å¿ƒè·³ æŠ˜ç·šåœ–
            slideLabel.innerText = `${units[slideIdx].code} ${units[slideIdx].name} ${units[slideIdx].topic}`;
        }, 3000);

        // å•Ÿå‹•éŠæˆ²å‡½æ•¸
        window.startGame = function() {
            const input = document.getElementById('hero-name');
            const name = input.value.trim();
            if (name === "") {
                alert("âš  ç³»çµ±è­¦å‘Šï¼šå¿…é ˆè¼¸å…¥å‹‡è€…ä»£è™Ÿæ‰èƒ½å•Ÿå‹•å¼•æ“ï¼");
                return;
            }
            playerName = name;
            document.getElementById('display-name').innerText = playerName;
            
            // UI åˆ‡æ›
            document.getElementById('intro-layer').style.display = 'none';
            document.getElementById('game-canvas').style.display = 'block';
            document.getElementById('ui-layer').style.display = 'block';
            
            // å•Ÿå‹•éŸ³æ•ˆèˆ‡éŠæˆ²è¿´åœˆ
            gameStarted = true;
            if(audioEngine.context && audioEngine.context.state === 'suspended') {
                audioEngine.context.resume();
            }
            audioEngine.play().catch(e=>{});
            animate(); // é–‹å§‹æ¸²æŸ“è¿´åœˆ
        }

        // æ’è¡Œæ¦œå‡½æ•¸
        window.toggleLeaderboard = function() {
            const modal = document.getElementById('leaderboard-modal');
            if (modal.style.display === 'block') {
                modal.style.display = 'none';
            } else {
                modal.style.display = 'block';
                // å¦‚æœæœ‰è¼¸å…¥åå­—ï¼Œå‹•æ…‹åŠ åˆ°è¡¨æ ¼æ¨¡æ“¬ä¸€ä¸‹
                const inputName = document.getElementById('hero-name').value.trim();
                if(inputName) {
                    const table = document.getElementById('lb-table-body');
                    // ç°¡å–®é˜²å‘†ï¼Œä¸é‡è¤‡åŠ 
                    if(!table.innerHTML.includes(inputName)) {
                        table.innerHTML += `<tr style="color:#00f3ff"><td>NEW</td><td>${inputName}</td><td>æº–å‚™å‡ºç™¼</td></tr>`;
                    }
                }
            }
        }

        // --- 2. ç³»çµ±è®Šæ•¸ (Three.js éŠæˆ²é‚è¼¯) ---
        const config = {
            speed: 0,
            maxSpeed: 2.8,       
            baseMaxSpeed: 2.8,   
            slowMaxSpeed: 0.6,   
            rotSpeed: 0.05,
            accel: 0.1,
            friction: 0.96,
            treeCount: 300,
            mapSize: 800
        };

        const keys = { w: false, a: false, s: false, d: false, space: false };
        let activeUnit = null;
        let lootScore = 0;
        const markers = []; 
        let enemies = [];   
        let bullets = [];   
        let enemyBullets = []; 
        let hqActive = false;
        let hqMesh = null;
        let repairTimer = null;
        
        let isWarping = false; 
        let warpTarget = new THREE.Vector3(); 

        // --- 3. Three.js å ´æ™¯ ---
        const scene = new THREE.Scene();
        const fogColor = new THREE.Color(0x334422);
        scene.background = fogColor;
        scene.fog = new THREE.FogExp2(fogColor, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const textureLoader = new THREE.TextureLoader();
        const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();

        // --- 4. ç‡ˆå…‰ ---
        const hemiLight = new THREE.HemisphereLight(0xffffee, 0x224422, 0.8);
        scene.add(hemiLight);

        const sunLight = new THREE.DirectionalLight(0xffddaa, 1.2);
        sunLight.position.set(150, 200, -100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048; 
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.left = -500; sunLight.shadow.camera.right = 500;
        sunLight.shadow.camera.top = 500; sunLight.shadow.camera.bottom = -500;
        scene.add(sunLight);

        // --- 5. ç’°å¢ƒç”Ÿæˆ ---
        function getGroundHeight(x, z) {
            return Math.sin(x * 0.02) * Math.cos(z * 0.02) * 6;
        }

        const groundGeo = new THREE.PlaneGeometry(1200, 1200, 64, 64);
        const pos = groundGeo.attributes.position;
        for(let i=0; i<pos.count; i++){
            const x = pos.getX(i); const y = pos.getY(i); 
            const h = getGroundHeight(x, y); 
            pos.setZ(i, h);
        }
        groundGeo.computeVertexNormals();
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x2e3b23, roughness: 0.9 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        function getRandPos(minDist=50) {
            let x, z;
            do {
                x = (Math.random()-0.5) * config.mapSize;
                z = (Math.random()-0.5) * config.mapSize;
            } while (Math.abs(x) < minDist && Math.abs(z) < minDist);
            return {x, z};
        }

        const trunkGeo = new THREE.CylinderGeometry(0.6, 1.8, 12, 7);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3b2a });
        const leafGeo = new THREE.DodecahedronGeometry(5);
        const leafMat = new THREE.MeshStandardMaterial({ color: 0x1e4d2b });
        
        for(let i=0; i<config.treeCount; i++){
            const grp = new THREE.Group();
            const t = new THREE.Mesh(trunkGeo, trunkMat); t.position.y=6; t.castShadow=true;
            const l = new THREE.Mesh(leafGeo, leafMat); l.position.y=11; l.castShadow=true;
            l.rotation.set(Math.random(), Math.random(), Math.random());
            grp.add(t, l);
            const p = getRandPos();
            const gh = getGroundHeight(p.x, p.z);
            grp.position.set(p.x, gh - 1, p.z);
            grp.scale.setScalar(Math.random()*0.8+0.7);
            scene.add(grp);
        }

        // --- 6. ä»»å‹™å…‰æŸ±èˆ‡åœ°æ¿æŠ•å½± & æ•µäººç”Ÿæˆ ---
        function spawnEnemy(x, z, isGuard = false) {
            const enemyGrp = new THREE.Group();

            const silhouetteMat = new THREE.MeshStandardMaterial({
                color: 0x111111, roughness: 0.9, metalness: 0.0
            });

            const bodyGeo = new THREE.CylinderGeometry(0.6, 1.0, 3.5, 16);
            const body = new THREE.Mesh(bodyGeo, silhouetteMat); body.position.y = 1.75;
            const headGeo = new SphereGeometry(0.5, 16, 16);
            const head = new THREE.Mesh(headGeo, silhouetteMat); head.position.y = 3.8;
            const hatBrimGeo = new THREE.CylinderGeometry(1.3, 1.3, 0.1, 16);
            const hatBrim = new THREE.Mesh(hatBrimGeo, silhouetteMat); hatBrim.position.y = 4.1;
            const hatTopGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.8, 16);
            const hatTop = new THREE.Mesh(hatTopGeo, silhouetteMat); hatTop.position.y = 4.5;

            enemyGrp.add(body, head, hatBrim, hatTop);
            const gh = getGroundHeight(x, z);
            enemyGrp.position.set(x, gh, z);
            enemyGrp.traverse(o => { if(o.isMesh) o.castShadow = true; });
            enemyGrp.rotation.y = Math.random() * Math.PI * 2;
            
            scene.add(enemyGrp);
            
            enemies.push({ 
                mesh: enemyGrp, active: true, isGuard: isGuard,
                velocity: new THREE.Vector3((Math.random()-0.5)*0.2, 0, (Math.random()-0.5)*0.2), 
                moveTimer: 0, attackCooldown: 0
            });
        }

        units.forEach((u, idx) => {
            const isFirstSem = u.id <= 10;
            const color = isFirstSem ? 0x39ff14 : 0x00f3ff;
            const angle = (idx / units.length) * Math.PI * 2;
            const r = Math.random() * 320 + 80;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            const terrainH = getGroundHeight(x, z);

            const beamGeo = new THREE.CylinderGeometry(0.4, 0.4, 30, 16);
            const beamMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.4 });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            const ring = new THREE.Mesh(new THREE.RingGeometry(2.5, 3, 32), new THREE.MeshBasicMaterial({color: color, side:THREE.DoubleSide}));
            ring.rotation.x = -Math.PI/2;
            beam.position.set(x, terrainH + 15, z);
            ring.position.set(x, terrainH + 0.5, z);
            scene.add(beam);
            scene.add(ring);

            const imgTex = textureLoader.load(`${u.id}.jpg`, undefined, undefined, (err) => { });
            imgTex.anisotropy = maxAnisotropy;
            
            const imgGeo = new THREE.PlaneGeometry(10, 10);
            const imgMat = new THREE.MeshBasicMaterial({ 
                map: imgTex, transparent: true, opacity: 0.9, side: THREE.DoubleSide, color: 0xffffff 
            });
            const imgMesh = new THREE.Mesh(imgGeo, imgMat);
            imgMesh.rotation.x = -Math.PI / 2;
            imgMesh.position.set(x, terrainH + 0.8, z);
            scene.add(imgMesh);

            const lightGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0x00f3ff });
            const lightBox = new THREE.Mesh(lightGeo, lightMat);
            lightBox.position.set(x, terrainH + 12, z);
            scene.add(lightBox);

            const floatGeo = new THREE.PlaneGeometry(8, 8);
            const floatMat = new THREE.MeshBasicMaterial({ 
                map: imgTex, transparent: true, opacity: 0.9, side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending, depthWrite: false
            });
            const floatMesh = new THREE.Mesh(floatGeo, floatMat);
            floatMesh.position.set(x, terrainH + 10, z);
            scene.add(floatMesh);

            markers.push({ 
                x: x, z: z, data: u, mesh: beam, floatMesh: floatMesh, lightMesh: lightBox, baseY: terrainH 
            });

            const guardCount = Math.floor(Math.random() * 2) + 1;
            for(let k=0; k<guardCount; k++) {
                spawnEnemy(x + (Math.random()-0.5)*20, z + (Math.random()-0.5)*20, true);
            }
        });

        for(let i=0; i<30; i++) {
            const p = getRandPos(60);
            spawnEnemy(p.x, p.z, false);
        }

        // --- 7. äººé¡ç¸½éƒ¨ (HQ) ---
        function createHQ() {
            const hqGroup = new THREE.Group();
            const baseGeo = new THREE.CylinderGeometry(15, 20, 10, 6);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.1 });
            const base = new THREE.Mesh(baseGeo, baseMat); base.position.y = 5;
            const towerGeo = new THREE.BoxGeometry(8, 30, 8);
            const towerMat = new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0xffaa00, emissiveIntensity: 0.8 });
            const tower = new THREE.Mesh(towerGeo, towerMat); tower.position.y = 15;
            hqGroup.add(base, tower);
            hqGroup.position.set(380, 0, 380);
            hqGroup.visible = false;
            scene.add(hqGroup);
            return hqGroup;
        }
        hqMesh = createHQ();

        // --- 8. ç©å®¶è¼‰å…· ---
        const playerGroup = new THREE.Group();
        const frameMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4, metalness: 0.6 });
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 2.2), frameMat); body.position.y = 1.2;
        playerGroup.add(body);
        const neonMat = new THREE.MeshStandardMaterial({ color: 0x00f3ff, emissive: 0x00f3ff, emissiveIntensity: 2.0 });
        const fairing = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.4, 1.4), neonMat); fairing.position.set(0, 1.4, 0.2);
        playerGroup.add(fairing);
        const wheelGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.3, 24);
        const rubberMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.9 });
        const rimGeo = new THREE.TorusGeometry(0.4, 0.05, 16, 16);
        const backWheelGrp = new THREE.Group(); backWheelGrp.add(new THREE.Mesh(wheelGeo, rubberMat).rotateZ(1.57), new THREE.Mesh(rimGeo, neonMat).rotateY(1.57));
        backWheelGrp.position.set(0, 0.7, -1.2); playerGroup.add(backWheelGrp);
        const frontWheelGrp = new THREE.Group(); frontWheelGrp.add(new THREE.Mesh(wheelGeo, rubberMat).rotateZ(1.57), new THREE.Mesh(rimGeo, neonMat).rotateY(1.57));
        frontWheelGrp.position.set(0, 0.7, 1.6); playerGroup.add(frontWheelGrp);
        const headLight = new THREE.SpotLight(0xffffff, 3, 60, 0.5, 0.5, 1);
        headLight.position.set(0, 2, 1.5); headLight.target.position.set(0, 0, 15);
        playerGroup.add(headLight); playerGroup.add(headLight.target);
        playerGroup.traverse(o => { if(o.isMesh) o.castShadow = true; });
        scene.add(playerGroup);

        // --- 9. æˆ°é¬¥ç³»çµ± ---
        function shootGas() {
            const geo = new THREE.IcosahedronGeometry(0.8, 0); 
            const mat = new THREE.MeshBasicMaterial({ color: 0x39ff14, transparent: true, opacity: 0.6 });
            const bullet = new THREE.Mesh(geo, mat);
            bullet.position.copy(playerGroup.position);
            bullet.position.y += 1.5;
            bullet.position.add(new THREE.Vector3(0,0,2).applyAxisAngle(new THREE.Vector3(0,1,0), playerGroup.rotation.y));
            const velocity = new THREE.Vector3(0, 0, 4).applyAxisAngle(new THREE.Vector3(0, 1, 0), playerGroup.rotation.y);
            bullet.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            scene.add(bullet);
            bullets.push({ mesh: bullet, vel: velocity, life: 60 });
            audioShoot.currentTime = 0; audioShoot.play().catch(e=>{});
        }

        function enemyShoot(enemy) {
            const geo = new THREE.CylinderGeometry(0.1, 0.1, 2, 8); 
            const mat = new THREE.MeshBasicMaterial({ color: 0xff3333 }); 
            const bullet = new THREE.Mesh(geo, mat);
            bullet.position.copy(enemy.mesh.position); bullet.position.y += 2.5; 
            const dir = new THREE.Vector3().subVectors(playerGroup.position, enemy.mesh.position).normalize();
            const velocity = dir.multiplyScalar(0.8); 
            bullet.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
            bullet.rotateX(Math.PI / 2);
            scene.add(bullet);
            enemyBullets.push({ mesh: bullet, vel: velocity, life: 80 });
        }

        // --- 10. æˆ°è¡“é›·é” ---
        const mmCanvas = document.getElementById('minimap-canvas');
        const mmCtx = mmCanvas.getContext('2d');
        function updateMinimap() {
            const w = mmCanvas.width; const h = mmCanvas.height;
            mmCtx.fillStyle = 'rgba(0, 20, 0, 0.8)'; mmCtx.fillRect(0, 0, w, h);
            mmCtx.fillStyle = '#39ff14'; mmCtx.beginPath(); mmCtx.arc(w/2, h/2, 3, 0, Math.PI*2); mmCtx.fill();
            const px = playerGroup.position.x; const pz = playerGroup.position.z;
            mmCtx.fillStyle = '#00f3ff';
            markers.forEach(m => {
                const dx = (m.x - px) / 10; const dy = (m.z - pz) / 10;
                if (Math.abs(dx) < w/2 && Math.abs(dy) < h/2) mmCtx.fillRect(w/2 + dx, h/2 + dy, 3, 3);
            });
            mmCtx.fillStyle = '#ff3333';
            enemies.forEach(e => {
                if(!e.active) return;
                const ex = e.mesh.position.x; const ez = e.mesh.position.z;
                const dx = (ex - px) / 10; const dy = (ez - pz) / 10;
                if (Math.abs(dx) < w/2 && Math.abs(dy) < h/2) {
                    mmCtx.beginPath(); mmCtx.arc(w/2 + dx, h/2 + dy, 2.5, 0, Math.PI*2); mmCtx.fill();
                }
            });
            if (hqActive) {
                const hx = hqMesh.position.x; const hz = hqMesh.position.z;
                const dx = (hx - px) / 10; const dy = (hz - pz) / 10;
                mmCtx.fillStyle = '#ffd700';
                mmCtx.beginPath(); mmCtx.arc(w/2 + dx, h/2 + dy, 6, 0, Math.PI*2); mmCtx.fill();
            }
        }

        // --- 11. æ§åˆ¶é‚è¼¯ ---
        window.addEventListener('keydown', (e) => {
            if (!gameStarted || isWarping) return;
            const k = e.key.toLowerCase(); const c = e.code;
            if (k === 'w' || c === 'ArrowUp') keys.w = true;
            if (k === 's' || c === 'ArrowDown') keys.s = true;
            if (k === 'a' || c === 'ArrowLeft') keys.a = true;
            if (k === 'd' || c === 'ArrowRight') keys.d = true;
            if (c === 'Space' && !keys.space) { shootGas(); keys.space = true; }
            if (c === 'Enter' && activeUnit) triggerWarp(activeUnit);
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase(); const c = e.code;
            if (k === 'w' || c === 'ArrowUp') keys.w = false;
            if (k === 's' || c === 'ArrowDown') keys.s = false;
            if (k === 'a' || c === 'ArrowLeft') keys.a = false;
            if (k === 'd' || c === 'ArrowRight') keys.d = false;
            if (c === 'Space') keys.space = false;
        });

        function getUrl(id, type) {
            const base = id <= 10 ? "https://jessiemath05.github.io/First-game" : "https://jessiemath0703g5.github.io/second-game";
            let folder = `${id}`;
            if (type === 'basic') return `${base}${folder}/`;
            if (type === 'adv') return `${base}${folder}-1/`;
            if (type === 'play') return `${base}${folder}-play/`;
        }

        function triggerWarp(u) {
            isWarping = true; config.speed = 0; 
            audioWarp.currentTime = 0; audioWarp.play().catch(e=>{});
            document.body.classList.add('warping');
            warpTarget.set(u.x, 2, u.z); 
            setTimeout(() => { openUI(u); isWarping = false; document.body.classList.remove('warping'); }, 1500);
        }

        window.openUI = function(u) {
            document.getElementById('mission-modal').style.display = 'block';
            document.getElementById('m-title').innerText = `${u.code} ${u.name}`;
            document.getElementById('m-desc').innerText = `${u.desc} (${u.topic})`; // åœ¨ä»»å‹™è¦–çª—é¡¯ç¤ºè©³ç´°èªªæ˜èˆ‡ä¸»é¡Œ
            document.getElementById('link-1').href = getUrl(u.id, 'basic');
            document.getElementById('link-2').href = getUrl(u.id, 'adv');
            document.getElementById('link-3').href = getUrl(u.id, 'play');
        }
        window.closeUI = function() { document.getElementById('mission-modal').style.display = 'none'; }
        
        window.getLoot = function() {
            lootScore++;
            document.getElementById('progress').innerText = lootScore;
            // æ›´æ–°æ’è¡Œæ¦œé¡¯ç¤º (ç°¡å–®æ¨¡æ“¬)
            const rows = document.getElementById('lb-table-body').rows;
            if(rows.length > 3 && rows[3].cells[1].innerText === playerName) {
                rows[3].cells[2].innerText = `${lootScore}/21`;
            }

            let msgText = "ç²å¾—ç‰©è³‡ï¼";
            if (enemies.length > 5) {
                let removeCount = Math.floor(Math.random() * 2) + 2;
                for(let i=0; i<enemies.length; i++) {
                    if (removeCount <= 0) break;
                    if (enemies[i].active && !enemies[i].isGuard) {
                        enemies[i].active = false; scene.remove(enemies[i].mesh); removeCount--;
                    }
                }
            }
            const threatSpan = document.getElementById('threat-level');
            if (lootScore > 15) threatSpan.innerText = "ä½ (å„ªå‹¢)";
            else if (lootScore > 8) threatSpan.innerText = "ä¸­ç­‰";
            else threatSpan.innerText = "æ¥µé«˜";

            if (lootScore >= 11 && !hqActive) {
                hqActive = true; hqMesh.visible = true; msgText = "åµæ¸¬åˆ°äººé¡ç¸½éƒ¨è¨Šè™Ÿï¼";
                document.getElementById('hq-warning').style.display = 'block';
                setTimeout(() => document.getElementById('hq-warning').style.display = 'none', 5000);
                for(let i=0; i<6; i++) {
                    const angle = (i/6)*Math.PI*2;
                    spawnEnemy(380 + Math.cos(angle)*30, 380 + Math.sin(angle)*30, true);
                }
            }
            const msg = document.getElementById('reward-msg');
            msg.innerText = msgText; msg.style.opacity = 1;
            setTimeout(() => msg.style.opacity = 0, 2000);
        }
        function checkWin() { alert("æ­å–œï¼ä½ æ‘§æ¯€äº†è³‡æºé–‹ç™¼ç¸½ç½²ï¼Œå®ˆè­·äº†å¢æ—ï¼"); location.reload(); }

        // --- 12. éŠæˆ²ä¸»è¿´åœˆ ---
        function animate() {
            if (!gameStarted) return; // å¦‚æœé‚„æ²’ç™»å…¥ï¼Œä¸åŸ·è¡Œæ¸²æŸ“

            requestAnimationFrame(animate);

            if (Math.abs(config.speed) > 0.1 && !isWarping) {
                if (audioEngine.paused) audioEngine.play().catch(e=>{});
            } else {
                if (!audioEngine.paused) audioEngine.pause();
            }

            if (isWarping) {
                camera.position.lerp(warpTarget, 0.05);
                camera.lookAt(warpTarget.x, 0, warpTarget.z);
            } else {
                if (keys.w) config.speed += config.accel;
                if (keys.s) config.speed -= config.accel;
                config.speed *= config.friction;
                config.speed = Math.max(Math.min(config.speed, config.maxSpeed), -config.maxSpeed/2);
                
                if (Math.abs(config.speed) > 0.05) {
                    const dir = config.speed > 0 ? 1 : -1;
                    if (keys.a) playerGroup.rotation.y += config.rotSpeed * dir;
                    if (keys.d) playerGroup.rotation.y -= config.rotSpeed * dir;
                    backWheelGrp.rotation.x += config.speed * 0.5;
                    frontWheelGrp.rotation.x += config.speed * 0.5;
                }
                playerGroup.position.x += Math.sin(playerGroup.rotation.y) * config.speed;
                playerGroup.position.z += Math.cos(playerGroup.rotation.y) * config.speed;

                const camOffset = new THREE.Vector3(0, 6, -14).applyMatrix4(playerGroup.matrixWorld);
                camera.position.lerp(camOffset, 0.1);
                camera.lookAt(playerGroup.position.clone().add(new THREE.Vector3(0, 3, 0)));
            }

            // --- æ•µäººé‚è¼¯ ---
            enemies.forEach(e => {
                if (!e.active) return;
                e.moveTimer++;
                if (e.moveTimer > 60 + Math.random()*60) {
                    const distToPlayer = e.mesh.position.distanceTo(playerGroup.position);
                    if (distToPlayer < 50 && distToPlayer > 10) {
                        const dir = new THREE.Vector3().subVectors(playerGroup.position, e.mesh.position).normalize();
                        e.velocity = dir.multiplyScalar(0.25); 
                    } else {
                        e.velocity.set((Math.random()-0.5)*0.2, 0, (Math.random()-0.5)*0.2);
                    }
                    e.moveTimer = 0;
                }
                e.mesh.position.add(e.velocity);
                e.mesh.lookAt(e.mesh.position.clone().add(e.velocity));
                if (Math.abs(e.mesh.position.x) > 400 || Math.abs(e.mesh.position.z) > 400) e.velocity.negate();

                e.attackCooldown--;
                const dist = e.mesh.position.distanceTo(playerGroup.position);
                if (dist < 40 && e.attackCooldown <= 0) { 
                    enemyShoot(e);
                    e.attackCooldown = 120 + Math.random() * 60; 
                }
            });

            // ç©å®¶å­å½ˆ
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.mesh.position.add(b.vel);
                b.mesh.rotation.x += 0.05;
                b.life--;
                let hit = false;
                for (let j = 0; j < enemies.length; j++) {
                    const e = enemies[j];
                    if (e.active && b.mesh.position.distanceTo(e.mesh.position) < 2.5) {
                        e.active = false; scene.remove(e.mesh); hit = true;
                        const combatHint = document.getElementById('combat-hint');
                        combatHint.innerText = "æ“Šæšˆäººé¡ï¼"; combatHint.style.color = "#ff3333";
                        setTimeout(() => { combatHint.innerText = "æŒ‰ [ç©ºç™½éµ] ç™¼å°„æ¯’æ°£ | å°å¿ƒäººé¡æ”»æ“Šï¼"; combatHint.style.color = "#39ff14"; }, 1000);
                        break;
                    }
                }
                if (b.life <= 0 || hit) { scene.remove(b.mesh); bullets.splice(i, 1); }
            }

            // --- æ•µäººå­å½ˆ & ç©å®¶å—å‚· ---
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const eb = enemyBullets[i];
                eb.mesh.position.add(eb.vel);
                eb.life--;
                
                if (eb.mesh.position.distanceTo(playerGroup.position) < 1.5) {
                    config.speed = 0; config.maxSpeed = config.slowMaxSpeed; 
                    const overlay = document.getElementById('damage-overlay');
                    overlay.style.opacity = 1; setTimeout(() => overlay.style.opacity = 0, 300);
                    const combatHint = document.getElementById('combat-hint');
                    combatHint.innerText = "è­¦å‘Šï¼šæ©Ÿé«”å—æï¼é€Ÿåº¦å¤§å¹…ä¸‹é™ (30s)"; combatHint.style.color = "#ff3333";
                    if (repairTimer) clearTimeout(repairTimer);
                    repairTimer = setTimeout(() => {
                        config.maxSpeed = config.baseMaxSpeed; 
                        combatHint.innerText = "æ©Ÿé«”ä¿®å¾©å®Œæˆ - å‹•åŠ›æ¢å¾©"; combatHint.style.color = "#39ff14";
                        setTimeout(() => { combatHint.innerText = "æŒ‰ [ç©ºç™½éµ] ç™¼å°„æ¯’æ°£ | å°å¿ƒäººé¡æ”»æ“Šï¼"; }, 2000);
                    }, 30000); 
                    scene.remove(eb.mesh); enemyBullets.splice(i, 1); continue;
                }
                if (eb.life <= 0) { scene.remove(eb.mesh); enemyBullets.splice(i, 1); }
            }

            enemies.forEach(e => {
                if (e.active && playerGroup.position.distanceTo(e.mesh.position) < 3) {
                    config.speed *= -0.5; e.active = false; scene.remove(e.mesh);
                }
            });

            if (hqActive && playerGroup.position.distanceTo(hqMesh.position) < 25) checkWin();

            // ä»»å‹™åµæ¸¬
            activeUnit = null; let near = false;
            markers.forEach(m => {
                const dist = playerGroup.position.distanceTo(new THREE.Vector3(m.x, playerGroup.position.y, m.z));
                m.mesh.rotation.y += 0.02;
                m.floatMesh.quaternion.copy(camera.quaternion);
                const time = Date.now() * 0.002;
                m.floatMesh.position.y = m.baseY + 10 + Math.sin(time + m.x) * 0.5;
                m.lightMesh.position.y = m.baseY + 12 + Math.sin(time + m.x) * 0.5;
                if (dist < 8) { activeUnit = m.data; near = true; }
            });

            const hint = document.getElementById('hint-box');
            if (near && !isWarping && document.getElementById('mission-modal').style.display !== 'block') { 
                hint.style.display = 'block'; 
                hint.innerText = `ç™¼ç¾ [${activeUnit.code} - ${activeUnit.name} - ${activeUnit.topic}] æŒ‰ Enter é€²å…¥`; 
            } else { hint.style.display = 'none'; }

            document.getElementById('speed-display').innerText = Math.abs(Math.round(config.speed * 40));
            updateMinimap();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
    </script>
</body>
</html>